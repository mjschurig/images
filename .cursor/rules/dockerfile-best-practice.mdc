---
description: 
globs: Dockerfile
alwaysApply: false
---
# Dockerfile Best Practices

## Purpose
This guide provides comprehensive best practices for writing production-ready Dockerfiles that are secure, efficient, and maintainable. These practices help create optimized container images with minimal attack surface, faster build times, and better performance.

## Core Principles
- **Security First**: Run as non-root user, use specific tags, minimize attack surface
- **Efficiency**: Optimize layer caching, minimize image size, reduce build time
- **Maintainability**: Use clear instructions, consistent patterns, and proper documentation
- **Reproducibility**: Ensure consistent builds across environments

## Implementation

### 1. Base Image Selection

**Use Official Images**
```dockerfile
# Good: Use official images
FROM node:18-alpine
FROM python:3.11-slim
FROM nginx:1.24

# Avoid: Building from scratch unless necessary
FROM ubuntu
RUN wget -qO- https://nodejs.org/dist/...
```

**Choose Appropriate Base Images**
- Use official images when available (tested by millions of users)
- Consider `slim` variants for smaller size without Alpine complications
- Alpine isn't always the best choice (performance issues with some technologies)
- Evaluate security vs. size trade-offs

**Pin Specific Versions**
```dockerfile
# Good: Specific major.minor version
FROM node:18.17-alpine

# Avoid: Latest tag
FROM node:latest
FROM node
```

### 2. Security Best Practices

**Run as Non-Root User**
```dockerfile
# Create user with UID > 10000
RUN groupadd -g 10001 appgroup && \
    useradd -u 10000 -g appgroup appuser && \
    chown -R appuser:appgroup /app

USER appuser:appgroup
```

**Use Static UID/GID**
- Always use UID > 10000 to avoid system user conflicts
- Use consistent UID/GID across all containers (e.g., 10000:10001)
- This enables predictable file permission management

**Minimize Attack Surface**
```dockerfile
# Remove unnecessary packages
RUN apt-get update && apt-get install -y \
    curl \
    git \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean
```

### 3. Layer Optimization

**Combine RUN Instructions**
```dockerfile
# Good: Single layer
RUN apt-get update && apt-get install -y \
    curl \
    git \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Avoid: Multiple layers
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y git
```

**Order Instructions by Change Frequency**
```dockerfile
# Dependencies change less frequently
COPY package*.json ./
RUN npm ci --only=production

# Source code changes more frequently
COPY . .
```

**Use .dockerignore**
```dockerignore
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.nyc_output
coverage
.coverage
```

### 4. Instruction Best Practices

**COPY vs ADD**
```dockerfile
# Good: Use COPY for local files
COPY package.json ./
COPY src/ ./src/

# Only use ADD for tar auto-extraction
ADD archive.tar.xz /usr/share/

# Avoid: ADD for URLs (security risk)
ADD https://example.com/file.tar.gz ./
```

**ENTRYPOINT and CMD**
```dockerfile
# Good: Separate concerns
ENTRYPOINT ["/sbin/tini", "--", "myapp"]
CMD ["--foo", "5", "--bar=10"]

# This allows: docker run image --custom-arg
```

**WORKDIR Usage**
```dockerfile
# Good: Use WORKDIR
WORKDIR /app
COPY . .

# Avoid: Manual directory changes
RUN cd /app && cp ...
```

### 5. Multi-Stage Builds

**Separate Build and Runtime**
```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine AS production
WORKDIR /app
RUN addgroup -g 10001 -S appgroup && \
    adduser -u 10000 -S appuser -G appgroup
COPY --from=builder --chown=appuser:appgroup /app/dist ./dist
COPY --from=builder --chown=appuser:appgroup /app/package*.json ./
RUN npm ci --only=production && npm cache clean --force
USER appuser:appgroup
EXPOSE 3000
CMD ["node", "dist/index.js"]
```

### 6. Environment and Configuration

**Use Build Arguments**
```dockerfile
ARG NODE_VERSION=18
FROM node:${NODE_VERSION}-alpine

ARG BUILD_DATE
LABEL build-date=${BUILD_DATE}
```

**Set Environment Variables**
```dockerfile
ENV NODE_ENV=production
ENV PORT=3000
ENV ASPNETCORE_URLS=http://*:5000
```

**Expose Ports Appropriately**
```dockerfile
# Document the port, don't bind to privileged ports
EXPOSE 3000
```

### 7. Health Checks and Metadata

**Add Health Checks**
```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1
```

**Include Metadata**
```dockerfile
LABEL maintainer="team@company.com"
LABEL version="1.0.0"
LABEL description="Application description"
```

## Best Practices

### Do's
- Use official base images when available
- Pin specific versions (major.minor, not latest)
- Run as non-root user with UID > 10000
- Use static UID/GID (10000:10001)
- Combine RUN instructions to minimize layers
- Use COPY instead of ADD (except for tar extraction)
- Order instructions by change frequency
- Use multi-stage builds for smaller production images
- Include .dockerignore file
- Add health checks for services
- Clean up package caches and temporary files

### Don'ts
- Don't use `latest` tag in production
- Don't run as root user
- Don't use ADD for downloading files from URLs
- Don't create unnecessary layers
- Don't include development dependencies in production images
- Don't hardcode secrets in Dockerfile
- Don't use UID below 10000
- Don't forget to clean up after package installations

### Common Pitfalls
- **Cache Invalidation**: Copying source code before installing dependencies
- **Security**: Running as root or using privileged ports
- **Size**: Including unnecessary files or not using multi-stage builds
- **Reproducibility**: Using `latest` tags or not pinning versions
- **Performance**: Not optimizing layer order or using inefficient base images

## Example Production Dockerfile

```dockerfile
# Multi-stage build for Node.js application
FROM node:18.17-alpine AS builder

# Install build dependencies
RUN apk add --no-cache python3 make g++

WORKDIR /app

# Copy dependency files
COPY package*.json ./

# Install all dependencies (including dev)
RUN npm ci

# Copy source code
COPY . .

# Build application
RUN npm run build && npm prune --production

# Production stage
FROM node:18.17-alpine AS production

# Create non-root user
RUN addgroup -g 10001 -S appgroup && \
    adduser -u 10000 -S appuser -G appgroup

WORKDIR /app

# Copy built application and production dependencies
COPY --from=builder --chown=appuser:appgroup /app/dist ./dist
COPY --from=builder --chown=appuser:appgroup /app/node_modules ./node_modules
COPY --from=builder --chown=appuser:appgroup /app/package*.json ./

# Switch to non-root user
USER appuser:appgroup

# Expose port
EXPOSE 3000

# Add health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

# Set environment
ENV NODE_ENV=production

# Start application
CMD ["node", "dist/index.js"]
```

## References
- @Docker Official Best Practices
- @Docker Dockerfile Reference
- @Community Best Practices
- @Multi-stage Builds Documentation
- @Security Best Practices

*Last modified: 2025-01-27*
